#ifndef XMLObject_H
#define XMLObject_H
#include <memory>
#include <sstream>
#include <string>
#include <unordered_map>
#include <vector>
#include <list>

#include <xercesc/dom/DOM.hpp>

namespace XML {

class XMLObject;

typedef std::string ClassName;
typedef std::string ElementName;
typedef std::string TextContent;
typedef std::string Namespace;
typedef std::string AttributeName;
typedef std::string AttributeValue;
struct Attribute {
  Namespace prefix;
  AttributeName name;
  AttributeValue value;
  operator std::string() const { return value; };
  operator bool() const { return (value == "true"); };
  operator int() const { return std::stoi(value); };
  operator double() const  { return std::stod(value); };
  Attribute& operator=(const std::string& s) { value = s; return *this; };
  Attribute& operator=(const bool& b) { value = (b ? "true" : "false"); return *this; };
  Attribute& operator=(const int& i) { value = std::to_string(i); return *this; };
  Attribute& operator=(const double& d) { value = std::to_string(d); return *this; };
};
typedef std::vector<Attribute> Attributes;
typedef std::vector<std::unique_ptr<XMLObject>> Children;

template<typename T> XMLObject* createInstance(const ClassName& className, const xercesc::DOMElement* element, XMLObject* parent) { return new T(className, element, parent, T::defaults); } /// Template function used to store in factory

typedef std::unordered_map<ElementName, XMLObject* (*)(const ClassName& className, const xercesc::DOMElement* element, XMLObject* parent)> Factory; /// Factory used to create instance depending on element name


/**
 * XMLObject
 *
 * A class allowing to read and store an XML-tree. The root element can be created using
 * - XMLObject::createFromStream(xmlStream)
 * - XMLObject::createFromString(xmlString)
 * - XMLObject::createFromFile(filename)
 *
 * Each instance has a
 * - className: refers to the class it belong to
 * - elementName: refers to the name used in the XML
 * - prefix (optional): refers to the namespace prefix in the XML (or empty if no namespace is given): 
 * - attributes: a list of attributes containing the namespace prefix, the attribute name, and the attribute value
 * - children: a list of child elements
 * - parent: a pointer to the parent element (or nullptr is root element) 
 *
 * Derived classes providing dedicated members for attributes and children belonging to the respective XML element according to an XML schema defintion are automatically generated by schematicpp. 
 */
class XMLObject {

public:
	static XMLObject* createFromStream(std::istream& xmlStream);
	static XMLObject* createFromString(std::string& xmlString);
	static XMLObject* createFromFile(std::string& filename);

  virtual ~XMLObject() {};

protected:
  static XMLObject* createObject(const xercesc::DOMElement* element, XMLObject* parent);



template<typename T> friend XMLObject* createInstance(const ClassName& className, const xercesc::DOMElement* element, XMLObject* parent); 

protected:
  XMLObject(const ClassName& className, const xercesc::DOMElement* element, XMLObject* parent, const Attributes& defaultAttributes);

  inline static Factory factory;
  inline static Attribute _attribute_; ///> placeholder to be used for temporary initialization of references
public:
  template<typename T> bool is() {
    return ( dynamic_cast<T*>(this) != nullptr );
  }

  template<typename T> T* get() {
    T* ptr = dynamic_cast<T*>(this); 
    if ( ptr == nullptr ) {
      throw std::runtime_error("XMLObject: Illegal cast");
    }
    return ptr; 
  };



  Namespace prefix;
  ElementName elementName;
  const ClassName className;

  XMLObject* parent;
  TextContent textContent; ///< textual content of XML element without children
  Children children; ///< child nodes of the XML element
  Attributes attributes; /// attributes of the XML element
	inline static const Attributes defaults = {};

  std::string stringify() const;

  template<typename T> T& getRequiredChild() {
    for ( auto& child : children ) {
      if ( child->is<T>() ) {
        return *child->get<T>();
      }
    }
    throw std::runtime_error("Failed to get required child of element '" + elementName + "'");
  }

  template<typename T> std::optional< std::reference_wrapper<T> > getOptionalChild() {
    for ( auto& child : children ) {
      if ( child->is<T>() ) {
        return *child->get<T>();
      }
    }
    return std::nullopt;
  }

  template<typename T> std::vector< std::reference_wrapper<T> > getChildren() {
    std::vector< std::reference_wrapper<T> > result;
    for ( auto& child : children ) {
      if ( child->is<T>() ) {
        result.push_back(*child->get<T>());
      }
    }
    return result;
  }

  Attribute& getRequiredAttributeByName(const AttributeName& attributeName);
  std::optional< std::reference_wrapper<Attribute> > getOptionalAttributeByName(const AttributeName& attributeName);


};

std::ostream& operator<< (std::ostream& os, const XMLObject* obj);
std::ostream& operator<< (std::ostream& os, const XMLObject& obj);

} // end namespace XML

#endif // XML_H
